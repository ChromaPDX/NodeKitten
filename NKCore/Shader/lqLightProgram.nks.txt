@interface

struct LightProperties {
    vec3 position;
    vec3 ambient;
    vec3 color;
    
    vec3 halfVector;
    vec3 coneDirection;
    
    float spotCosCutoff;
    float spotExponent;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    
    bool isEnabled;
    bool isLocal;
    bool isSpot;
};

@interface

@vertmain

v_eyeDirection = v_position.xyz;

if (u_light.isLocal) {

    v_lightDirection =  u_light.position - v_position.xyz;
    float lightDistance = length(v_lightDirection);
    v_lightDirection = v_lightDirection / lightDistance; // (normalize) ? ;
    v_attenuation = 1.0 / (u_light.constantAttenuation + (u_light.linearAttenuation * lightDistance) + (u_light.quadraticAttenuation * lightDistance * lightDistance));
    if (u_light.isSpot) {
        float spotCos = dot(v_lightDirection,-u_light.coneDirection);
        if (spotCos < u_light.spotCosCutoff) v_attenuation = 0.0;
        else v_attenuation *= pow(spotCos,u_light.spotExponent);
    }
    v_halfVector = normalize(v_lightDirection + v_eyeDirection);

}
else {
    v_halfVector = u_light.halfVector;
}

@vertmain

@fragmain
//
// LIGHT PROGRAM
//

vec3 scatteredLight = vec3(0.0);
vec3 reflectedLight = vec3(0.0);

float Strength = 2.;
float Shininess = 20.;

if (u_numLights > 0){
for (int i = 0; i < u_numLights; i++){

float diffuse = max(0.0, dot(v_normal, v_lightDirection));
//float specular = max(0.0, dot(v_normal, v_halfVector));
float specular = max(0.0, dot(reflect(v_lightDirection, v_normal), v_halfVector));

if (diffuse == 0.0) specular = 0.0;
else specular = pow(specular, Shininess) * Strength;
// Accumulate all the u_lightsâ€™ effects
scatteredLight += u_light.ambient * v_attenuation + u_light.color * diffuse * v_attenuation;
reflectedLight += u_light.color * specular * v_attenuation;
}
//lightColor = vec4(min(reflectedLight,vec3(1.0)), 1.0);
lightColor = vec4(min(scatteredLight+reflectedLight,vec3(1.0)), 1.0);
}
else {
lightColor = vec4(1.0);
}

@fragmain

